<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîê Encryption/Decryption Module Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #222;
        }
        .status {
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            display: inline-block;
            margin: 5px;
        }
        .status.success { background: #4caf50; color: white; }
        .status.error { background: #f44336; color: white; }
        .status.info { background: #2196f3; color: white; }
        .btn {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        .btn:hover { background: #00cc00; }
        .output {
            background: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #333;
        }
        .metric {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            min-width: 150px;
            text-align: center;
        }
        .hex-display {
            font-family: 'Courier New', monospace;
            word-break: break-all;
            color: #ffff00;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê ENCRYPTION/DECRYPTION MODULE TEST</h1>
            <p>Comprehensive testing of AES-256-GCM cryptographic operations</p>
        </div>

        <div class="test-section">
            <h2>üìä Test Metrics</h2>
            <div class="metric">
                <div>Encryption Operations</div>
                <div id="encryptCount">0</div>
            </div>
            <div class="metric">
                <div>Decryption Operations</div>
                <div id="decryptCount">0</div>
            </div>
            <div class="metric">
                <div>Data Processed (KB)</div>
                <div id="dataProcessed">0</div>
            </div>
            <div class="metric">
                <div>Average Time (ms)</div>
                <div id="avgTime">0</div>
            </div>
        </div>

        <div class="test-section">
            <h2>üß™ Basic Encryption Test</h2>
            <button class="btn" onclick="testBasicEncryption()">Run Basic Test</button>
            <div class="output" id="basicOutput"></div>
        </div>

        <div class="test-section">
            <h2>üìù Text Data Test</h2>
            <textarea placeholder="Enter text to encrypt..." id="textInput" style="width: 100%; height: 100px; background: #333; color: #fff; border: 1px solid #666; padding: 10px;">This is a sample text for encryption testing.
It includes multiple lines, special characters !@#$%^&*(), and unicode: üîêüöÄ‚ú®</textarea>
            <br>
            <button class="btn" onclick="testTextEncryption()">Encrypt Text</button>
            <button class="btn" onclick="testTextDecryption()">Decrypt Text</button>
            <div class="output" id="textOutput"></div>
        </div>

        <div class="test-section">
            <h2>üìÅ Binary Data Test</h2>
            <button class="btn" onclick="testBinaryEncryption()">Test Binary Data</button>
            <div class="output" id="binaryOutput"></div>
        </div>

        <div class="test-section">
            <h2>‚ö° Performance Test</h2>
            <button class="btn" onclick="testPerformance()">Run Performance Test</button>
            <div class="output" id="perfOutput"></div>
        </div>

        <div class="test-section">
            <h2>üîÑ Stress Test</h2>
            <button class="btn" onclick="testStress()">Run Stress Test</button>
            <div class="output" id="stressOutput"></div>
        </div>

        <div class="test-section">
            <h2>üìã Complete Report</h2>
            <button class="btn" onclick="generateReport()">Generate Report</button>
            <div class="output" id="reportOutput"></div>
        </div>
    </div>

    <script>
        let encryptCount = 0;
        let decryptCount = 0;
        let totalDataProcessed = 0;
        let totalTime = 0;
        let testResults = [];
        let currentKey = null;
        let encryptedData = null;
        let currentIV = null;

        function updateMetrics() {
            document.getElementById('encryptCount').textContent = encryptCount;
            document.getElementById('decryptCount').textContent = decryptCount;
            document.getElementById('dataProcessed').textContent = Math.round(totalDataProcessed / 1024);
            document.getElementById('avgTime').textContent = totalTime > 0 ? Math.round(totalTime / (encryptCount + decryptCount)) : 0;
        }

        function log(outputId, message, type = 'info') {
            const output = document.getElementById(outputId);
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function arrayBufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        async function generateKey() {
            return await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        async function testBasicEncryption() {
            const output = 'basicOutput';
            document.getElementById(output).textContent = '';
            
            try {
                log(output, 'Starting basic encryption test...');
                
                // Generate key
                const key = await generateKey();
                currentKey = key;
                log(output, 'AES-256-GCM key generated successfully');
                
                // Test data
                const plaintext = 'Hello, CryptoVault! This is a basic encryption test.';
                const encoder = new TextEncoder();
                const data = encoder.encode(plaintext);
                
                log(output, `Original text: "${plaintext}"`);
                log(output, `Data size: ${data.byteLength} bytes`);
                
                // Generate IV
                const iv = crypto.getRandomValues(new Uint8Array(12));
                currentIV = iv;
                log(output, `IV generated: ${arrayBufferToHex(iv)}`);
                
                // Encrypt
                const startTime = performance.now();
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );
                const encryptTime = performance.now() - startTime;
                
                encryptedData = encrypted;
                encryptCount++;
                totalDataProcessed += data.byteLength;
                totalTime += encryptTime;
                
                log(output, `Encryption completed in ${encryptTime.toFixed(2)}ms`);
                log(output, `Encrypted size: ${encrypted.byteLength} bytes`);
                log(output, `Encrypted data (hex): ${arrayBufferToHex(encrypted).substring(0, 64)}...`);
                
                // Decrypt
                const decryptStartTime = performance.now();
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                const decryptTime = performance.now() - decryptStartTime;
                
                decryptCount++;
                totalTime += decryptTime;
                
                const decoder = new TextDecoder();
                const decryptedText = decoder.decode(decrypted);
                
                log(output, `Decryption completed in ${decryptTime.toFixed(2)}ms`);
                log(output, `Decrypted text: "${decryptedText}"`);
                
                // Verify
                if (decryptedText === plaintext) {
                    log(output, 'SUCCESS: Encryption/Decryption cycle completed successfully!', 'success');
                    testResults.push({ test: 'Basic', status: 'PASS', time: encryptTime + decryptTime });
                } else {
                    log(output, 'ERROR: Decrypted text does not match original!', 'error');
                    testResults.push({ test: 'Basic', status: 'FAIL', time: encryptTime + decryptTime });
                }
                
                updateMetrics();
                
            } catch (error) {
                log(output, `ERROR: ${error.message}`, 'error');
                testResults.push({ test: 'Basic', status: 'ERROR', error: error.message });
            }
        }

        async function testTextEncryption() {
            const output = 'textOutput';
            const textInput = document.getElementById('textInput').value;
            
            if (!textInput.trim()) {
                log(output, 'Please enter some text to encrypt', 'error');
                return;
            }
            
            try {
                log(output, 'Starting text encryption...');
                
                if (!currentKey) {
                    currentKey = await generateKey();
                    log(output, 'New encryption key generated');
                }
                
                const encoder = new TextEncoder();
                const data = encoder.encode(textInput);
                
                log(output, `Input text length: ${textInput.length} characters`);
                log(output, `Data size: ${data.byteLength} bytes`);
                
                const iv = crypto.getRandomValues(new Uint8Array(12));
                currentIV = iv;
                
                const startTime = performance.now();
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    currentKey,
                    data
                );
                const encryptTime = performance.now() - startTime;
                
                encryptedData = encrypted;
                encryptCount++;
                totalDataProcessed += data.byteLength;
                totalTime += encryptTime;
                
                log(output, `Text encrypted in ${encryptTime.toFixed(2)}ms`);
                log(output, `Encrypted size: ${encrypted.byteLength} bytes`);
                log(output, `Encryption ratio: ${(encrypted.byteLength / data.byteLength * 100).toFixed(1)}%`);
                
                const hexPreview = arrayBufferToHex(encrypted).substring(0, 128);
                log(output, `Encrypted data preview: ${hexPreview}...`);
                
                updateMetrics();
                log(output, 'Text encryption completed successfully!', 'success');
                
            } catch (error) {
                log(output, `Encryption error: ${error.message}`, 'error');
            }
        }

        async function testTextDecryption() {
            const output = 'textOutput';
            
            if (!encryptedData || !currentKey || !currentIV) {
                log(output, 'No encrypted data available. Please encrypt text first.', 'error');
                return;
            }
            
            try {
                log(output, 'Starting text decryption...');
                
                const startTime = performance.now();
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: currentIV },
                    currentKey,
                    encryptedData
                );
                const decryptTime = performance.now() - startTime;
                
                decryptCount++;
                totalTime += decryptTime;
                
                const decoder = new TextDecoder();
                const decryptedText = decoder.decode(decrypted);
                
                log(output, `Text decrypted in ${decryptTime.toFixed(2)}ms`);
                log(output, `Decrypted size: ${decrypted.byteLength} bytes`);
                log(output, `Decrypted text: "${decryptedText}"`);
                
                updateMetrics();
                log(output, 'Text decryption completed successfully!', 'success');
                
            } catch (error) {
                log(output, `Decryption error: ${error.message}`, 'error');
            }
        }

        async function testBinaryEncryption() {
            const output = 'binaryOutput';
            document.getElementById(output).textContent = '';
            
            try {
                log(output, 'Starting binary data encryption test...');
                
                // Create test binary data
                const binaryData = new Uint8Array(1000);
                for (let i = 0; i < binaryData.length; i++) {
                    binaryData[i] = i % 256;
                }
                
                log(output, `Created test binary data: ${binaryData.length} bytes`);
                log(output, `Data pattern: ${Array.from(binaryData.slice(0, 20)).join(', ')}...`);
                
                const key = await generateKey();
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                // Encrypt
                const startTime = performance.now();
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    binaryData
                );
                const encryptTime = performance.now() - startTime;
                
                encryptCount++;
                totalDataProcessed += binaryData.byteLength;
                totalTime += encryptTime;
                
                log(output, `Binary data encrypted in ${encryptTime.toFixed(2)}ms`);
                log(output, `Original size: ${binaryData.byteLength} bytes`);
                log(output, `Encrypted size: ${encrypted.byteLength} bytes`);
                
                // Decrypt
                const decryptStartTime = performance.now();
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                const decryptTime = performance.now() - decryptStartTime;
                
                decryptCount++;
                totalTime += decryptTime;
                
                const decryptedArray = new Uint8Array(decrypted);
                
                log(output, `Binary data decrypted in ${decryptTime.toFixed(2)}ms`);
                log(output, `Decrypted size: ${decryptedArray.byteLength} bytes`);
                
                // Verify
                let isMatch = binaryData.length === decryptedArray.length;
                if (isMatch) {
                    for (let i = 0; i < binaryData.length; i++) {
                        if (binaryData[i] !== decryptedArray[i]) {
                            isMatch = false;
                            break;
                        }
                    }
                }
                
                if (isMatch) {
                    log(output, 'SUCCESS: Binary data integrity verified!', 'success');
                    testResults.push({ test: 'Binary', status: 'PASS', time: encryptTime + decryptTime });
                } else {
                    log(output, 'ERROR: Binary data integrity check failed!', 'error');
                    testResults.push({ test: 'Binary', status: 'FAIL', time: encryptTime + decryptTime });
                }
                
                updateMetrics();
                
            } catch (error) {
                log(output, `Binary test error: ${error.message}`, 'error');
                testResults.push({ test: 'Binary', status: 'ERROR', error: error.message });
            }
        }

        async function testPerformance() {
            const output = 'perfOutput';
            document.getElementById(output).textContent = '';
            
            try {
                log(output, 'Starting performance test...');
                
                const sizes = [1024, 10240, 102400, 1048576]; // 1KB, 10KB, 100KB, 1MB
                const key = await generateKey();
                
                for (const size of sizes) {
                    log(output, `Testing ${size / 1024}KB data...`);
                    
                    // Create test data
                    const data = new Uint8Array(size);
                    for (let i = 0; i < size; i++) {
                        data[i] = Math.random() * 256;
                    }
                    
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    // Encrypt
                    const encryptStart = performance.now();
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        data
                    );
                    const encryptTime = performance.now() - encryptStart;
                    
                    // Decrypt
                    const decryptStart = performance.now();
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encrypted
                    );
                    const decryptTime = performance.now() - decryptStart;
                    
                    encryptCount++;
                    decryptCount++;
                    totalDataProcessed += size * 2;
                    totalTime += encryptTime + decryptTime;
                    
                    const throughputMBps = (size / 1024 / 1024) / ((encryptTime + decryptTime) / 1000);
                    
                    log(output, `  Encrypt: ${encryptTime.toFixed(2)}ms, Decrypt: ${decryptTime.toFixed(2)}ms`);
                    log(output, `  Throughput: ${throughputMBps.toFixed(2)} MB/s`);
                }
                
                updateMetrics();
                log(output, 'Performance test completed!', 'success');
                testResults.push({ test: 'Performance', status: 'PASS', time: totalTime });
                
            } catch (error) {
                log(output, `Performance test error: ${error.message}`, 'error');
                testResults.push({ test: 'Performance', status: 'ERROR', error: error.message });
            }
        }

        async function testStress() {
            const output = 'stressOutput';
            document.getElementById(output).textContent = '';
            
            try {
                log(output, 'Starting stress test...');
                log(output, 'Testing 100 concurrent encryption operations...');
                
                const key = await generateKey();
                const promises = [];
                const stressStartTime = performance.now();
                
                for (let i = 0; i < 100; i++) {
                    const data = new TextEncoder().encode(`Stress test message ${i}`);
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    const promise = crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        data
                    ).then(encrypted => {
                        return crypto.subtle.decrypt(
                            { name: 'AES-GCM', iv: iv },
                            key,
                            encrypted
                        );
                    });
                    
                    promises.push(promise);
                }
                
                const results = await Promise.all(promises);
                const stressTime = performance.now() - stressStartTime;
                
                encryptCount += 100;
                decryptCount += 100;
                totalTime += stressTime;
                
                log(output, `Completed 100 operations in ${stressTime.toFixed(2)}ms`);
                log(output, `Average per operation: ${(stressTime / 200).toFixed(2)}ms`);
                log(output, `Operations per second: ${(200 / (stressTime / 1000)).toFixed(0)}`);
                
                updateMetrics();
                log(output, 'Stress test completed successfully!', 'success');
                testResults.push({ test: 'Stress', status: 'PASS', time: stressTime });
                
            } catch (error) {
                log(output, `Stress test error: ${error.message}`, 'error');
                testResults.push({ test: 'Stress', status: 'ERROR', error: error.message });
            }
        }

        function generateReport() {
            const output = 'reportOutput';
            document.getElementById(output).textContent = '';
            
            log(output, 'üìã ENCRYPTION/DECRYPTION MODULE TEST REPORT');
            log(output, '='.repeat(50));
            log(output, `Test Date: ${new Date().toISOString()}`);
            log(output, `Browser: ${navigator.userAgent}`);
            log(output, '');
            
            log(output, 'üìä STATISTICS:');
            log(output, `Total Encryption Operations: ${encryptCount}`);
            log(output, `Total Decryption Operations: ${decryptCount}`);
            log(output, `Total Data Processed: ${Math.round(totalDataProcessed / 1024)} KB`);
            log(output, `Average Operation Time: ${totalTime > 0 ? Math.round(totalTime / (encryptCount + decryptCount)) : 0} ms`);
            log(output, '');
            
            log(output, 'üß™ TEST RESULTS:');
            testResults.forEach(result => {
                const status = result.status === 'PASS' ? '‚úÖ' : result.status === 'FAIL' ? '‚ùå' : '‚ö†Ô∏è';
                log(output, `${status} ${result.test}: ${result.status}`);
                if (result.time) {
                    log(output, `   Time: ${result.time.toFixed(2)}ms`);
                }
                if (result.error) {
                    log(output, `   Error: ${result.error}`);
                }
            });
            
            log(output, '');
            log(output, 'üîê ALGORITHM DETAILS:');
            log(output, 'Algorithm: AES-256-GCM');
            log(output, 'Key Length: 256 bits');
            log(output, 'IV Length: 96 bits (12 bytes)');
            log(output, 'Tag Length: 128 bits (16 bytes)');
            log(output, 'Implementation: Web Crypto API');
            
            const passedTests = testResults.filter(r => r.status === 'PASS').length;
            const totalTests = testResults.length;
            
            log(output, '');
            log(output, `üéØ OVERALL RESULT: ${passedTests}/${totalTests} tests passed`);
            
            if (passedTests === totalTests && totalTests > 0) {
                log(output, 'üéâ ALL TESTS PASSED! Encryption/Decryption module working perfectly!', 'success');
            } else {
                log(output, '‚ö†Ô∏è Some tests failed. Please review the results above.', 'error');
            }
        }

        // Initialize
        window.addEventListener('load', () => {
            log('basicOutput', 'üîê Encryption/Decryption Module Test Ready');
            console.log('üîê Encryption Test Module Loaded');
        });
    </script>
</body>
</html>