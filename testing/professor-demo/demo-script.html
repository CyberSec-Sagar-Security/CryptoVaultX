<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéì CryptoVaultX - Professor Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .test-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }
        
        .test-card:hover {
            transform: translateY(-5px);
        }
        
        .test-card h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .test-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .status-pending {
            background: #ff9800;
            color: white;
        }
        
        .status-running {
            background: #2196f3;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .status-success {
            background: #4caf50;
            color: white;
        }
        
        .status-error {
            background: #f44336;
            color: white;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .btn {
            background: linear-gradient(45deg, #4caf50, #45a049);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .results {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .feature-list {
            list-style: none;
            padding: 0;
        }
        
        .feature-list li {
            padding: 8px 0;
            border-left: 3px solid #4caf50;
            padding-left: 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        
        .summary-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            text-align: center;
        }
        
        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéì CryptoVaultX Professor Demo</h1>
            <p>Comprehensive demonstration of Encryption/Decryption and Key Management modules</p>
            <div class="test-status status-pending" id="overallStatus">Ready to Start</div>
        </div>

        <div class="test-grid">
            <!-- Test 1: Key Management -->
            <div class="test-card">
                <h3>üîë Key Management Module</h3>
                <p>Demonstrates secure key generation and management using WebCrypto API</p>
                <ul class="feature-list">
                    <li>AES-256-GCM key generation</li>
                    <li>Session-based key storage</li>
                    <li>Key export/import functionality</li>
                    <li>Secure key lifecycle management</li>
                </ul>
                <div class="test-status status-pending" id="keyStatus">Pending</div>
                <div class="results" id="keyResults" style="display: none;"></div>
                <button class="btn" onclick="testKeyManagement()" id="keyBtn">Test Key Management</button>
            </div>

            <!-- Test 2: Encryption/Decryption -->
            <div class="test-card">
                <h3>üîê Encryption/Decryption Module</h3>
                <p>Validates client-side cryptographic operations</p>
                <ul class="feature-list">
                    <li>AES-256-GCM encryption</li>
                    <li>Random IV generation</li>
                    <li>Authentication tag verification</li>
                    <li>Data integrity validation</li>
                </ul>
                <div class="test-status status-pending" id="cryptoStatus">Pending</div>
                <div class="results" id="cryptoResults" style="display: none;"></div>
                <button class="btn" onclick="testEncryptionDecryption()" id="cryptoBtn">Test Encryption</button>
            </div>

            <!-- Test 3: File Upload Integration -->
            <div class="test-card">
                <h3>üì§ File Upload with Encryption</h3>
                <p>Complete workflow demonstration of encrypted file uploads</p>
                <ul class="feature-list">
                    <li>Client-side file encryption</li>
                    <li>Binary data handling</li>
                    <li>Metadata preservation</li>
                    <li>Upload simulation</li>
                </ul>
                <div class="test-status status-pending" id="uploadStatus">Pending</div>
                <div class="results" id="uploadResults" style="display: none;"></div>
                <button class="btn" onclick="testFileUpload()" id="uploadBtn">Test File Upload</button>
            </div>

            <!-- Test 4: Integration Test -->
            <div class="test-card">
                <h3>üîÑ End-to-End Integration</h3>
                <p>Complete workflow from encryption to decryption</p>
                <ul class="feature-list">
                    <li>File selection simulation</li>
                    <li>Full encryption workflow</li>
                    <li>Decryption and verification</li>
                    <li>Integrity checking</li>
                </ul>
                <div class="test-status status-pending" id="integrationStatus">Pending</div>
                <div class="results" id="integrationResults" style="display: none;"></div>
                <button class="btn" onclick="testIntegration()" id="integrationBtn">Test Integration</button>
            </div>
        </div>

        <div class="summary-card">
            <h2>üìä Test Summary</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
            <div class="summary-stats">
                <div class="stat">
                    <div class="stat-number" id="testsCompleted">0</div>
                    <div class="stat-label">Tests Completed</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="testsSucceeded">0</div>
                    <div class="stat-label">Tests Succeeded</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="encryptionOps">0</div>
                    <div class="stat-label">Encryption Operations</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="keysGenerated">0</div>
                    <div class="stat-label">Keys Generated</div>
                </div>
            </div>
            <button class="btn" onclick="runAllTests()" id="runAllBtn" style="font-size: 1.2em; padding: 15px 30px; margin-top: 20px;">
                üöÄ Run All Tests
            </button>
        </div>
    </div>

    <script>
        // Global variables for tracking
        let testsCompleted = 0;
        let testsSucceeded = 0;
        let encryptionOperations = 0;
        let keysGenerated = 0;
        let sessionKeys = new Map();

        // Utility functions
        function updateStatus(elementId, status, text) {
            const element = document.getElementById(elementId);
            element.className = `test-status status-${status}`;
            element.textContent = text;
        }

        function logResult(resultId, message, type = 'info') {
            const resultDiv = document.getElementById(resultId);
            resultDiv.style.display = 'block';
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3';
            resultDiv.innerHTML += `<div style="color: ${color};">[${timestamp}] ${message}</div>`;
            resultDiv.scrollTop = resultDiv.scrollHeight;
        }

        function updateProgress() {
            document.getElementById('testsCompleted').textContent = testsCompleted;
            document.getElementById('testsSucceeded').textContent = testsSucceeded;
            document.getElementById('encryptionOps').textContent = encryptionOperations;
            document.getElementById('keysGenerated').textContent = keysGenerated;
            
            const progress = (testsCompleted / 4) * 100;
            document.getElementById('overallProgress').style.width = progress + '%';
            
            if (testsCompleted === 4) {
                const overallStatus = testsSucceeded === 4 ? 'success' : 'error';
                const statusText = testsSucceeded === 4 ? '‚úÖ All Tests Passed!' : '‚ö†Ô∏è Some Tests Failed';
                updateStatus('overallStatus', overallStatus, statusText);
            }
        }

        // Test 1: Key Management
        async function testKeyManagement() {
            updateStatus('keyStatus', 'running', 'Testing...');
            logResult('keyResults', 'üîë Starting Key Management Test', 'info');
            
            try {
                // Test key generation
                logResult('keyResults', 'üìã Generating AES-256-GCM key...', 'info');
                const key1 = await window.crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                keysGenerated++;
                logResult('keyResults', '‚úÖ Key generated successfully', 'success');

                // Test key export
                logResult('keyResults', 'üì§ Exporting key...', 'info');
                const exportedKey = await window.crypto.subtle.exportKey('raw', key1);
                logResult('keyResults', `‚úÖ Key exported (${exportedKey.byteLength} bytes)`, 'success');

                // Test key import
                logResult('keyResults', 'üì• Importing key...', 'info');
                const importedKey = await window.crypto.subtle.importKey(
                    'raw',
                    exportedKey,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                logResult('keyResults', '‚úÖ Key imported successfully', 'success');

                // Store in session
                sessionKeys.set('testKey', importedKey);
                logResult('keyResults', 'üíæ Key stored in session storage', 'success');

                // Test multiple key generation
                logResult('keyResults', 'üîÑ Testing multiple key generation...', 'info');
                const keys = [];
                for (let i = 0; i < 3; i++) {
                    const key = await window.crypto.subtle.generateKey(
                        { name: 'AES-GCM', length: 256 },
                        true,
                        ['encrypt', 'decrypt']
                    );
                    keys.push(key);
                    keysGenerated++;
                }
                logResult('keyResults', `‚úÖ Generated ${keys.length} additional keys`, 'success');

                updateStatus('keyStatus', 'success', '‚úÖ Passed');
                testsCompleted++;
                testsSucceeded++;
                logResult('keyResults', 'üéâ Key Management Test PASSED!', 'success');

            } catch (error) {
                updateStatus('keyStatus', 'error', '‚ùå Failed');
                testsCompleted++;
                logResult('keyResults', `‚ùå Error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }

        // Test 2: Encryption/Decryption
        async function testEncryptionDecryption() {
            updateStatus('cryptoStatus', 'running', 'Testing...');
            logResult('cryptoResults', 'üîê Starting Encryption/Decryption Test', 'info');
            
            try {
                // Get or create test key
                let testKey = sessionKeys.get('testKey');
                if (!testKey) {
                    testKey = await window.crypto.subtle.generateKey(
                        { name: 'AES-GCM', length: 256 },
                        true,
                        ['encrypt', 'decrypt']
                    );
                    sessionKeys.set('testKey', testKey);
                    keysGenerated++;
                }

                // Test data
                const testData = "This is a test message for encryption. It contains special characters: !@#$%^&*() and unicode: üîêüöÄ";
                const encoder = new TextEncoder();
                const decoder = new TextDecoder();
                const originalData = encoder.encode(testData);
                
                logResult('cryptoResults', `üìù Original data: "${testData}"`, 'info');
                logResult('cryptoResults', `üìè Original size: ${originalData.byteLength} bytes`, 'info');

                // Generate IV
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                logResult('cryptoResults', `üé≤ Generated IV: ${Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')}`, 'info');

                // Encrypt
                logResult('cryptoResults', 'üîí Encrypting data...', 'info');
                const encryptedData = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    testKey,
                    originalData
                );
                encryptionOperations++;
                
                logResult('cryptoResults', `‚úÖ Encryption successful (${encryptedData.byteLength} bytes)`, 'success');

                // Verify it's actually encrypted (not readable)
                const encryptedArray = new Uint8Array(encryptedData);
                const encryptedHex = Array.from(encryptedArray.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join('');
                logResult('cryptoResults', `üîç Encrypted data (first 16 bytes): ${encryptedHex}...`, 'info');

                // Decrypt
                logResult('cryptoResults', 'üîì Decrypting data...', 'info');
                const decryptedData = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    testKey,
                    encryptedData
                );
                
                const decryptedText = decoder.decode(decryptedData);
                logResult('cryptoResults', `üìù Decrypted data: "${decryptedText}"`, 'success');

                // Verify integrity
                if (decryptedText === testData) {
                    logResult('cryptoResults', '‚úÖ Data integrity verified - perfect match!', 'success');
                } else {
                    throw new Error('Data integrity check failed');
                }

                // Test with different data types
                logResult('cryptoResults', 'üß™ Testing with binary data...', 'info');
                const binaryData = new Uint8Array([1, 2, 3, 4, 5, 255, 254, 253]);
                const iv2 = window.crypto.getRandomValues(new Uint8Array(12));
                
                const encryptedBinary = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv2 },
                    testKey,
                    binaryData
                );
                encryptionOperations++;
                
                const decryptedBinary = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv2 },
                    testKey,
                    encryptedBinary
                );
                
                const decryptedBinaryArray = new Uint8Array(decryptedBinary);
                const binaryMatch = Array.from(binaryData).every((val, index) => val === decryptedBinaryArray[index]);
                
                if (binaryMatch) {
                    logResult('cryptoResults', '‚úÖ Binary data encryption/decryption successful', 'success');
                } else {
                    throw new Error('Binary data integrity check failed');
                }

                updateStatus('cryptoStatus', 'success', '‚úÖ Passed');
                testsCompleted++;
                testsSucceeded++;
                logResult('cryptoResults', 'üéâ Encryption/Decryption Test PASSED!', 'success');

            } catch (error) {
                updateStatus('cryptoStatus', 'error', '‚ùå Failed');
                testsCompleted++;
                logResult('cryptoResults', `‚ùå Error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }

        // Test 3: File Upload Simulation
        async function testFileUpload() {
            updateStatus('uploadStatus', 'running', 'Testing...');
            logResult('uploadResults', 'üì§ Starting File Upload Test', 'info');
            
            try {
                // Create a simulated file
                const fileContent = `# CryptoVault Test Document

This is a test document to demonstrate file encryption before upload.

## Test Data
- Timestamp: ${new Date().toISOString()}
- Random number: ${Math.random()}
- Special characters: !@#$%^&*()_+-=[]{}|;:,.<>?
- Unicode: üîêüìÅüíæüöÄ‚ú®

## File Information
This file will be:
1. Encrypted using AES-256-GCM
2. Uploaded as encrypted binary data
3. Stored securely on the server
4. Decrypted only on the client side

End of test file.`;

                const encoder = new TextEncoder();
                const fileData = encoder.encode(fileContent);
                
                logResult('uploadResults', `üìÑ Created test file (${fileData.byteLength} bytes)`, 'info');
                logResult('uploadResults', `üìù File content preview: "${fileContent.substring(0, 50)}..."`, 'info');

                // Generate encryption key for upload
                logResult('uploadResults', 'üîë Generating upload encryption key...', 'info');
                const uploadKey = await window.crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                keysGenerated++;

                // Generate IV
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const ivBase64 = btoa(String.fromCharCode(...iv));
                logResult('uploadResults', `üé≤ Generated IV: ${ivBase64}`, 'info');

                // Encrypt file
                logResult('uploadResults', 'üîí Encrypting file for upload...', 'info');
                const encryptedFile = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    uploadKey,
                    fileData
                );
                encryptionOperations++;

                logResult('uploadResults', `‚úÖ File encrypted (${encryptedFile.byteLength} bytes)`, 'success');

                // Create upload metadata
                const metadata = {
                    originalFilename: 'test-document.md',
                    size: fileData.byteLength,
                    ivBase64: ivBase64,
                    algo: 'AES-256-GCM',
                    timestamp: new Date().toISOString()
                };

                logResult('uploadResults', `üìã Upload metadata: ${JSON.stringify(metadata, null, 2)}`, 'info');

                // Simulate upload (create blob)
                const encryptedBlob = new Blob([encryptedFile], { type: 'application/octet-stream' });
                logResult('uploadResults', `üì¶ Created upload blob (${encryptedBlob.size} bytes)`, 'success');

                // Verify the encrypted data is not readable
                const encryptedArray = new Uint8Array(encryptedFile);
                const firstBytes = Array.from(encryptedArray.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                logResult('uploadResults', `üîç Encrypted data (hex): ${firstBytes}...`, 'info');

                // Test decryption to verify process
                logResult('uploadResults', 'üîì Verifying decryption process...', 'info');
                const decryptedData = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    uploadKey,
                    encryptedFile
                );

                const decoder = new TextDecoder();
                const decryptedContent = decoder.decode(decryptedData);
                
                if (decryptedContent === fileContent) {
                    logResult('uploadResults', '‚úÖ Upload encryption/decryption cycle verified!', 'success');
                } else {
                    throw new Error('Upload encryption verification failed');
                }

                // Store key for integration test
                sessionKeys.set('uploadKey', uploadKey);
                sessionKeys.set('uploadIV', iv);
                sessionKeys.set('uploadData', encryptedFile);

                updateStatus('uploadStatus', 'success', '‚úÖ Passed');
                testsCompleted++;
                testsSucceeded++;
                logResult('uploadResults', 'üéâ File Upload Test PASSED!', 'success');

            } catch (error) {
                updateStatus('uploadStatus', 'error', '‚ùå Failed');
                testsCompleted++;
                logResult('uploadResults', `‚ùå Error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }

        // Test 4: Integration Test
        async function testIntegration() {
            updateStatus('integrationStatus', 'running', 'Testing...');
            logResult('integrationResults', 'üîÑ Starting Integration Test', 'info');
            
            try {
                logResult('integrationResults', 'üß™ Testing complete encryption workflow...', 'info');

                // Step 1: Key Generation
                logResult('integrationResults', '1Ô∏è‚É£ Generating session keys...', 'info');
                const encryptionKey = await window.crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                keysGenerated++;

                // Step 2: File Processing
                const testFiles = [
                    { name: 'document.txt', content: 'This is a text document with some content.' },
                    { name: 'data.json', content: '{"test": true, "value": 12345, "array": [1,2,3]}' },
                    { name: 'binary.dat', content: new Uint8Array([0, 1, 2, 255, 254, 253]) }
                ];

                const encryptedFiles = [];
                const encoder = new TextEncoder();

                for (let i = 0; i < testFiles.length; i++) {
                    const file = testFiles[i];
                    logResult('integrationResults', `2Ô∏è‚É£.${i+1} Processing file: ${file.name}`, 'info');

                    // Convert content to bytes
                    const fileData = file.content instanceof Uint8Array ? 
                        file.content : encoder.encode(file.content);

                    // Generate unique IV for each file
                    const iv = window.crypto.getRandomValues(new Uint8Array(12));

                    // Encrypt
                    const encrypted = await window.crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        encryptionKey,
                        fileData
                    );
                    encryptionOperations++;

                    encryptedFiles.push({
                        name: file.name,
                        originalData: fileData,
                        encryptedData: encrypted,
                        iv: iv
                    });

                    logResult('integrationResults', `   ‚úÖ ${file.name} encrypted (${encrypted.byteLength} bytes)`, 'success');
                }

                // Step 3: Verification
                logResult('integrationResults', '3Ô∏è‚É£ Verifying decryption integrity...', 'info');
                const decoder = new TextDecoder();

                for (let i = 0; i < encryptedFiles.length; i++) {
                    const file = encryptedFiles[i];
                    
                    // Decrypt
                    const decrypted = await window.crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: file.iv },
                        encryptionKey,
                        file.encryptedData
                    );

                    // Verify integrity
                    const originalArray = new Uint8Array(file.originalData);
                    const decryptedArray = new Uint8Array(decrypted);
                    
                    const isMatch = originalArray.length === decryptedArray.length &&
                        originalArray.every((val, index) => val === decryptedArray[index]);

                    if (isMatch) {
                        logResult('integrationResults', `   ‚úÖ ${file.name} integrity verified`, 'success');
                    } else {
                        throw new Error(`Integrity check failed for ${file.name}`);
                    }
                }

                // Step 4: Performance Test
                logResult('integrationResults', '4Ô∏è‚É£ Performance testing...', 'info');
                const startTime = performance.now();
                
                const largeData = new Uint8Array(100000); // 100KB
                for (let i = 0; i < largeData.length; i++) {
                    largeData[i] = i % 256;
                }

                const perfIV = window.crypto.getRandomValues(new Uint8Array(12));
                const encryptedLarge = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: perfIV },
                    encryptionKey,
                    largeData
                );
                encryptionOperations++;

                const decryptedLarge = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: perfIV },
                    encryptionKey,
                    encryptedLarge
                );

                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);

                logResult('integrationResults', `   ‚ö° Processed 100KB in ${duration}ms`, 'success');

                // Step 5: Summary
                logResult('integrationResults', '5Ô∏è‚É£ Integration test summary:', 'info');
                logResult('integrationResults', `   üìä Files processed: ${testFiles.length}`, 'info');
                logResult('integrationResults', `   üîë Keys generated: ${keysGenerated}`, 'info');
                logResult('integrationResults', `   üîí Encryption operations: ${encryptionOperations}`, 'info');
                logResult('integrationResults', `   ‚úÖ All integrity checks passed`, 'success');

                updateStatus('integrationStatus', 'success', '‚úÖ Passed');
                testsCompleted++;
                testsSucceeded++;
                logResult('integrationResults', 'üéâ Integration Test PASSED!', 'success');

            } catch (error) {
                updateStatus('integrationStatus', 'error', '‚ùå Failed');
                testsCompleted++;
                logResult('integrationResults', `‚ùå Error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }

        // Run all tests
        async function runAllTests() {
            // Reset counters
            testsCompleted = 0;
            testsSucceeded = 0;
            encryptionOperations = 0;
            keysGenerated = 0;
            sessionKeys.clear();

            // Clear previous results
            ['keyResults', 'cryptoResults', 'uploadResults', 'integrationResults'].forEach(id => {
                document.getElementById(id).innerHTML = '';
                document.getElementById(id).style.display = 'none';
            });

            // Reset statuses
            ['keyStatus', 'cryptoStatus', 'uploadStatus', 'integrationStatus'].forEach(id => {
                updateStatus(id, 'pending', 'Pending');
            });

            updateStatus('overallStatus', 'running', 'Running Tests...');
            
            // Disable run button
            document.getElementById('runAllBtn').disabled = true;
            
            try {
                await testKeyManagement();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testEncryptionDecryption();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testFileUpload();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testIntegration();
                
            } finally {
                document.getElementById('runAllBtn').disabled = false;
            }
        }

        // Initialize
        window.addEventListener('load', () => {
            console.log('üéì CryptoVaultX Professor Demo Loaded');
            console.log('Ready to demonstrate encryption and key management features');
        });
    </script>
</body>
</html>